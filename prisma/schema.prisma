generator client {
  provider = "prisma-client-js"
  output   = "../backend/node_modules/.prisma/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/// Tenant (Cliente/Empresa)
/// Cada tenant representa una empresa cliente del SaaS
model Tenant {
  id              String              @id @default(uuid()) @db.Uuid
  name            String              @db.VarChar(255)
  slug            String              @unique @db.VarChar(100)
  businessType    BusinessType
  isActive        Boolean             @default(true)
  settings        Json?
  maxUsers        Int                 @default(5)
  maxWarehouses   Int                 @default(3)
  maxProducts     Int                 @default(1000)
  createdAt       DateTime            @default(now()) @db.Timestamptz(6)
  updatedAt       DateTime            @updatedAt @db.Timestamptz(6)
  accountsPayable AccountPayable[]
  batches         Batch[]
  categories      Category[]
  audits          InventoryAudit[]
  movements       InventoryMovement[]
  families        ProductFamily[]
  products        Product[]
  purchaseOrders  PurchaseOrder[]
  suppliers       Supplier[]
  users           TenantUser[]
  warehouses      Warehouse[]

  @@index([slug])
  @@index([isActive])
  @@map("tenants")
}

/// Relación Tenant-Usuario (multi-tenant users)
model TenantUser {
  id        String   @id @default(uuid()) @db.Uuid
  tenantId  String   @db.Uuid
  userId    String   @db.Uuid
  role      UserRole @default(OPERATOR)
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @updatedAt @db.Timestamptz(6)
  tenant    Tenant   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([tenantId, userId])
  @@index([tenantId])
  @@index([userId])
  @@map("tenant_users")
}

/// Usuario del sistema
model User {
  id           String              @id @default(uuid()) @db.Uuid
  email        String              @unique @db.VarChar(255)
  passwordHash String              @db.VarChar(255)
  firstName    String              @db.VarChar(100)
  lastName     String              @db.VarChar(100)
  avatarUrl    String?             @db.VarChar(500)
  isActive     Boolean             @default(true)
  lastLoginAt  DateTime?           @db.Timestamptz(6)
  failedLogins Int                 @default(0)
  lockedUntil  DateTime?           @db.Timestamptz(6)
  createdAt    DateTime            @default(now()) @db.Timestamptz(6)
  updatedAt    DateTime            @updatedAt @db.Timestamptz(6)
  auditsClosed InventoryAudit[]    @relation("AuditClosedBy")
  movements    InventoryMovement[]
  tenants      TenantUser[]

  @@index([email])
  @@map("users")
}

/// Bodega/Almacén
model Warehouse {
  id            String              @id @default(uuid()) @db.Uuid
  tenantId      String              @db.Uuid
  name          String              @db.VarChar(255)
  code          String              @db.VarChar(50)
  address       String?             @db.VarChar(500)
  isDefault     Boolean             @default(false)
  isActive      Boolean             @default(true)
  settings      Json?
  createdAt     DateTime            @default(now()) @db.Timestamptz(6)
  updatedAt     DateTime            @updatedAt @db.Timestamptz(6)
  batches       Batch[]
  audits        InventoryAudit[]
  movementsTo   InventoryMovement[] @relation("MovementDestination")
  movementsFrom InventoryMovement[] @relation("MovementOrigin")
  tenant        Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantId, code])
  @@index([tenantId])
  @@index([tenantId, isDefault])
  @@map("warehouses")
}

/// Categoría de productos
model Category {
  id          String     @id @default(uuid()) @db.Uuid
  tenantId    String     @db.Uuid
  name        String     @db.VarChar(255)
  description String?
  parentId    String?    @db.Uuid
  sortOrder   Int        @default(0)
  isActive    Boolean    @default(true)
  createdAt   DateTime   @default(now()) @db.Timestamptz(6)
  updatedAt   DateTime   @updatedAt @db.Timestamptz(6)
  parent      Category?  @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children    Category[] @relation("CategoryHierarchy")
  tenant      Tenant     @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  products    Product[]

  @@unique([tenantId, name, parentId])
  @@index([tenantId])
  @@index([parentId])
  @@map("categories")
}

/// Familia de Productos (Unidad de Conversión)
///
/// DECISIÓN DE DISEÑO:
/// Las familias resuelven el problema de conversión de unidades.
/// Ejemplo: "Cocoa" tiene baseUnit=GRAM. Los productos como
/// "Bolsa 400g" o "Bolsa 900g" pertenecen a esta familia.
/// El campo conversionFactor del Product define cuántos gramos
/// tiene ese producto específico.
///
/// Esto permite:
/// 1. Calcular stock total en unidad base
/// 2. Sugerir órdenes de compra agregando necesidades
/// 3. Reportes unificados por familia
model ProductFamily {
  id              String    @id @default(uuid()) @db.Uuid
  tenantId        String    @db.Uuid
  name            String    @db.VarChar(255)
  description     String?
  baseUnit        BaseUnit  @default(UNIT)
  targetStockBase Decimal?  @db.Decimal(15, 4)
  isActive        Boolean   @default(true)
  createdAt       DateTime  @default(now()) @db.Timestamptz(6)
  updatedAt       DateTime  @updatedAt @db.Timestamptz(6)
  tenant          Tenant    @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  products        Product[]

  @@unique([tenantId, name])
  @@index([tenantId])
  @@map("product_families")
}

/// Producto
model Product {
  id                  String               @id @default(uuid()) @db.Uuid
  tenantId            String               @db.Uuid
  sku                 String               @db.VarChar(100)
  barcode             String?              @db.VarChar(100)
  name                String               @db.VarChar(255)
  description         String?
  categoryId          String               @db.Uuid
  familyId            String?              @db.Uuid
  conversionFactor    Decimal?             @db.Decimal(15, 4)
  stockMin            Decimal              @default(0) @db.Decimal(15, 4)
  stockIdeal          Decimal?             @db.Decimal(15, 4)
  stockMax            Decimal?             @db.Decimal(15, 4)
  costAverage         Decimal              @default(0) @db.Decimal(15, 4)
  priceDefault        Decimal?             @db.Decimal(15, 4)
  isService           Boolean              @default(false)
  hasExpiry           Boolean              @default(false)
  trackBatches        Boolean              @default(true)
  preferredSupplierId String?              @db.Uuid
  isActive            Boolean              @default(true)
  createdAt           DateTime             @default(now()) @db.Timestamptz(6)
  updatedAt           DateTime             @updatedAt @db.Timestamptz(6)
  metadata            Json?
  batches             Batch[]
  auditItems          InventoryAuditItem[]
  movements           InventoryMovement[]
  category            Category             @relation(fields: [categoryId], references: [id])
  family              ProductFamily?       @relation(fields: [familyId], references: [id])
  preferredSupplier   Supplier?            @relation(fields: [preferredSupplierId], references: [id])
  tenant              Tenant               @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  orderItems          PurchaseOrderItem[]

  @@unique([tenantId, sku])
  @@index([tenantId])
  @@index([tenantId, categoryId])
  @@index([tenantId, familyId])
  @@index([tenantId, barcode])
  @@index([tenantId, name])
  @@map("products")
}

/// Proveedor
model Supplier {
  id              String           @id @default(uuid()) @db.Uuid
  tenantId        String           @db.Uuid
  code            String           @db.VarChar(50)
  name            String           @db.VarChar(255)
  taxId           String?          @db.VarChar(50)
  contactName     String?          @db.VarChar(255)
  email           String?          @db.VarChar(255)
  phone           String?          @db.VarChar(50)
  address         String?
  paymentTermDays Int              @default(30)
  currency        String           @default("USD") @db.VarChar(3)
  rating          Decimal?         @db.Decimal(3, 2)
  isActive        Boolean          @default(true)
  createdAt       DateTime         @default(now()) @db.Timestamptz(6)
  updatedAt       DateTime         @updatedAt @db.Timestamptz(6)
  metadata        Json?
  payables        AccountPayable[]
  batches         Batch[]
  products        Product[]
  purchaseOrders  PurchaseOrder[]
  tenant          Tenant           @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantId, code])
  @@index([tenantId])
  @@index([tenantId, name])
  @@map("suppliers")
}

/// Lote de producto
///
/// DECISIÓN DE DISEÑO:
/// Los lotes NO reemplazan el stock; SON el stock.
/// Cada ingreso crea un nuevo lote con su propio:
/// - Costo unitario real (en ese momento)
/// - Fecha de vencimiento (si aplica)
/// - Ubicación (bodega)
///
/// Esto permite:
/// 1. Valorización FIFO/LIFO/Promedio real
/// 2. Trazabilidad completa
/// 3. Gestión de vencimientos (alertas proactivas)
model Batch {
  id              String              @id @default(uuid()) @db.Uuid
  tenantId        String              @db.Uuid
  productId       String              @db.Uuid
  warehouseId     String              @db.Uuid
  supplierId      String?             @db.Uuid
  batchNumber     String              @db.VarChar(100)
  quantityInitial Decimal             @db.Decimal(15, 4)
  quantityCurrent Decimal             @db.Decimal(15, 4)
  unitCost        Decimal             @db.Decimal(15, 4)
  currency        String              @default("USD") @db.VarChar(3)
  receivedAt      DateTime            @db.Timestamptz(6)
  expiresAt       DateTime?           @db.Timestamptz(6)
  isExhausted     Boolean             @default(false)
  isQuarantined   Boolean             @default(false)
  createdAt       DateTime            @default(now()) @db.Timestamptz(6)
  updatedAt       DateTime            @updatedAt @db.Timestamptz(6)
  metadata        Json?
  product         Product             @relation(fields: [productId], references: [id])
  supplier        Supplier?           @relation(fields: [supplierId], references: [id])
  tenant          Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  warehouse       Warehouse           @relation(fields: [warehouseId], references: [id])
  movements       InventoryMovement[]

  @@unique([tenantId, batchNumber])
  @@index([tenantId])
  @@index([tenantId, productId])
  @@index([tenantId, warehouseId])
  @@index([tenantId, expiresAt])
  @@index([quantityCurrent])
  @@map("batches")
}

/// Movimiento de inventario (Historial inmutable)
///
/// DECISIÓN DE DISEÑO:
/// Esta tabla es APPEND-ONLY. Los registros NUNCA se modifican.
/// Cada movimiento captura:
/// - Estado ANTES del movimiento
/// - Estado DESPUÉS del movimiento
/// - Quién lo hizo y cuándo
///
/// Soporta múltiples tipos de destino:
/// - warehouseDestinationId: Para traslados entre bodegas
/// - destinationType + destinationRef: Para consumos/ventas
model InventoryMovement {
  id                     String       @id @default(uuid()) @db.Uuid
  tenantId               String       @db.Uuid
  productId              String       @db.Uuid
  batchId                String?      @db.Uuid
  type                   MovementType
  quantity               Decimal      @db.Decimal(15, 4)
  stockBefore            Decimal      @db.Decimal(15, 4)
  stockAfter             Decimal      @db.Decimal(15, 4)
  warehouseOriginId      String?      @db.Uuid
  warehouseDestinationId String?      @db.Uuid
  destinationType        String?      @db.VarChar(50)
  destinationRef         String?      @db.VarChar(255)
  unitCost               Decimal?     @db.Decimal(15, 4)
  totalCost              Decimal?     @db.Decimal(15, 4)
  referenceType          String?      @db.VarChar(50)
  referenceId            String?      @db.Uuid
  performedById          String       @db.Uuid
  notes                  String?
  createdAt              DateTime     @default(now()) @db.Timestamptz(6)
  metadata               Json?
  batch                  Batch?       @relation(fields: [batchId], references: [id])
  performedBy            User         @relation(fields: [performedById], references: [id])
  product                Product      @relation(fields: [productId], references: [id])
  tenant                 Tenant       @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  warehouseDestination   Warehouse?   @relation("MovementDestination", fields: [warehouseDestinationId], references: [id])
  warehouseOrigin        Warehouse?   @relation("MovementOrigin", fields: [warehouseOriginId], references: [id])

  @@index([tenantId])
  @@index([tenantId, productId])
  @@index([tenantId, type])
  @@index([tenantId, createdAt])
  @@index([referenceType, referenceId])
  @@map("inventory_movements")
}

/// Auditoría de inventario (Conteo ciego)
model InventoryAudit {
  id            String               @id @default(uuid()) @db.Uuid
  tenantId      String               @db.Uuid
  warehouseId   String               @db.Uuid
  code          String               @db.VarChar(50)
  name          String               @db.VarChar(255)
  status        AuditStatus          @default(PENDING)
  scheduledAt   DateTime?            @db.Timestamptz(6)
  startedAt     DateTime?            @db.Timestamptz(6)
  completedAt   DateTime?            @db.Timestamptz(6)
  closedById    String?              @db.Uuid
  totalVariance Decimal?             @db.Decimal(15, 4)
  varianceCost  Decimal?             @db.Decimal(15, 4)
  notes         String?
  createdAt     DateTime             @default(now()) @db.Timestamptz(6)
  updatedAt     DateTime             @updatedAt @db.Timestamptz(6)
  items         InventoryAuditItem[]
  closedBy      User?                @relation("AuditClosedBy", fields: [closedById], references: [id])
  tenant        Tenant               @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  warehouse     Warehouse            @relation(fields: [warehouseId], references: [id])

  @@unique([tenantId, code])
  @@index([tenantId])
  @@index([tenantId, status])
  @@map("inventory_audits")
}

/// Ítem de auditoría
model InventoryAuditItem {
  id                   String         @id @default(uuid()) @db.Uuid
  auditId              String         @db.Uuid
  productId            String         @db.Uuid
  systemStock          Decimal        @db.Decimal(15, 4)
  countedStock         Decimal?       @db.Decimal(15, 4)
  variance             Decimal?       @db.Decimal(15, 4)
  varianceCost         Decimal?       @db.Decimal(15, 4)
  isAdjusted           Boolean        @default(false)
  adjustmentMovementId String?        @db.Uuid
  notes                String?
  createdAt            DateTime       @default(now()) @db.Timestamptz(6)
  updatedAt            DateTime       @updatedAt @db.Timestamptz(6)
  audit                InventoryAudit @relation(fields: [auditId], references: [id], onDelete: Cascade)
  product              Product        @relation(fields: [productId], references: [id])

  @@unique([auditId, productId])
  @@index([auditId])
  @@map("inventory_audit_items")
}

/// Orden de compra
model PurchaseOrder {
  id              String              @id @default(uuid()) @db.Uuid
  tenantId        String              @db.Uuid
  supplierId      String              @db.Uuid
  orderNumber     String              @db.VarChar(50)
  status          PurchaseOrderStatus @default(DRAFT)
  orderedAt       DateTime?           @db.Timestamptz(6)
  expectedAt      DateTime?           @db.Timestamptz(6)
  receivedAt      DateTime?           @db.Timestamptz(6)
  subtotal        Decimal             @default(0) @db.Decimal(15, 4)
  taxAmount       Decimal             @default(0) @db.Decimal(15, 4)
  discountAmount  Decimal             @default(0) @db.Decimal(15, 4)
  total           Decimal             @default(0) @db.Decimal(15, 4)
  currency        String              @default("USD") @db.VarChar(3)
  paymentTermDays Int?
  notes           String?
  createdAt       DateTime            @default(now()) @db.Timestamptz(6)
  updatedAt       DateTime            @updatedAt @db.Timestamptz(6)
  metadata        Json?
  payables        AccountPayable[]
  items           PurchaseOrderItem[]
  supplier        Supplier            @relation(fields: [supplierId], references: [id])
  tenant          Tenant              @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantId, orderNumber])
  @@index([tenantId])
  @@index([tenantId, status])
  @@index([tenantId, supplierId])
  @@map("purchase_orders")
}

/// Ítem de orden de compra
model PurchaseOrderItem {
  id               String        @id @default(uuid()) @db.Uuid
  orderId          String        @db.Uuid
  productId        String        @db.Uuid
  quantityOrdered  Decimal       @db.Decimal(15, 4)
  quantityReceived Decimal       @default(0) @db.Decimal(15, 4)
  unitPrice        Decimal       @db.Decimal(15, 4)
  discount         Decimal       @default(0) @db.Decimal(15, 4)
  taxRate          Decimal       @default(0) @db.Decimal(5, 4)
  total            Decimal       @db.Decimal(15, 4)
  notes            String?
  createdAt        DateTime      @default(now()) @db.Timestamptz(6)
  updatedAt        DateTime      @updatedAt @db.Timestamptz(6)
  order            PurchaseOrder @relation(fields: [orderId], references: [id], onDelete: Cascade)
  product          Product       @relation(fields: [productId], references: [id])

  @@index([orderId])
  @@index([productId])
  @@map("purchase_order_items")
}

/// Cuenta por pagar
///
/// DECISIÓN DE DISEÑO:
/// Esta tabla se genera AUTOMÁTICAMENTE cuando:
/// 1. Se recibe mercancía (ingreso con orden de compra)
/// 2. Se crea una obligación con proveedor
///
/// El trigger lógico está en la capa de aplicación (no DB trigger)
/// para mantener la lógica de negocio en el código y facilitar testing.
model AccountPayable {
  id              String          @id @default(uuid()) @db.Uuid
  tenantId        String          @db.Uuid
  supplierId      String          @db.Uuid
  purchaseOrderId String?         @db.Uuid
  invoiceNumber   String?         @db.VarChar(100)
  totalAmount     Decimal         @db.Decimal(15, 4)
  paidAmount      Decimal         @default(0) @db.Decimal(15, 4)
  balanceAmount   Decimal         @db.Decimal(15, 4)
  currency        String          @default("USD") @db.VarChar(3)
  issueDate       DateTime        @db.Timestamptz(6)
  dueDate         DateTime        @db.Timestamptz(6)
  paidAt          DateTime?       @db.Timestamptz(6)
  status          PayableStatus   @default(CURRENT)
  notes           String?
  createdAt       DateTime        @default(now()) @db.Timestamptz(6)
  updatedAt       DateTime        @updatedAt @db.Timestamptz(6)
  metadata        Json?
  purchaseOrder   PurchaseOrder?  @relation(fields: [purchaseOrderId], references: [id])
  supplier        Supplier        @relation(fields: [supplierId], references: [id])
  tenant          Tenant          @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  payments        PaymentRecord[]

  @@index([tenantId])
  @@index([tenantId, status])
  @@index([tenantId, dueDate])
  @@index([tenantId, supplierId])
  @@map("accounts_payable")
}

/// Registro de pago
model PaymentRecord {
  id            String         @id @default(uuid()) @db.Uuid
  payableId     String         @db.Uuid
  amount        Decimal        @db.Decimal(15, 4)
  currency      String         @default("USD") @db.VarChar(3)
  paymentMethod String         @db.VarChar(50)
  reference     String?        @db.VarChar(255)
  paidAt        DateTime       @db.Timestamptz(6)
  notes         String?
  createdAt     DateTime       @default(now()) @db.Timestamptz(6)
  metadata      Json?
  payable       AccountPayable @relation(fields: [payableId], references: [id], onDelete: Cascade)

  @@index([payableId])
  @@map("payment_records")
}

/// Sugerencia de reabastecimiento
/// Generadas automáticamente basándose en stockMin/stockIdeal/stockMax
model RestockSuggestion {
  id               String    @id @default(uuid()) @db.Uuid
  tenantId         String    @db.Uuid
  productId        String    @db.Uuid
  familyId         String?   @db.Uuid
  currentStock     Decimal   @db.Decimal(15, 4)
  targetStock      Decimal   @db.Decimal(15, 4)
  suggestedQty     Decimal   @db.Decimal(15, 4)
  suggestedQtyBase Decimal?  @db.Decimal(15, 4)
  priority         Int       @default(0)
  isProcessed      Boolean   @default(false)
  processedAt      DateTime? @db.Timestamptz(6)
  createdAt        DateTime  @default(now()) @db.Timestamptz(6)

  @@index([tenantId, isProcessed])
  @@index([tenantId, priority])
  @@map("restock_suggestions")
}

/// Alerta de inventario
model InventoryAlert {
  id            String    @id @default(uuid()) @db.Uuid
  tenantId      String    @db.Uuid
  alertType     String    @db.VarChar(50)
  severity      String    @db.VarChar(20)
  title         String    @db.VarChar(255)
  message       String
  referenceType String?   @db.VarChar(50)
  referenceId   String?   @db.Uuid
  isRead        Boolean   @default(false)
  readAt        DateTime? @db.Timestamptz(6)
  isDismissed   Boolean   @default(false)
  dismissedAt   DateTime? @db.Timestamptz(6)
  createdAt     DateTime  @default(now()) @db.Timestamptz(6)

  @@index([tenantId, isRead])
  @@index([tenantId, alertType])
  @@map("inventory_alerts")
}

/// Tipo de movimiento de inventario
enum MovementType {
  IN
  OUT
  TRANSFER
  AUDIT
  SALE
  CONSUME
}

/// Estado de cuenta por pagar
enum PayableStatus {
  CURRENT
  DUE_SOON
  OVERDUE
  PAID
  CANCELLED
}

/// Estado de orden de compra
enum PurchaseOrderStatus {
  DRAFT
  PENDING
  APPROVED
  ORDERED
  PARTIAL
  RECEIVED
  CANCELLED
}

/// Estado de auditoría de inventario
enum AuditStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  ADJUSTED
  CANCELLED
}

/// Tipo de negocio del tenant
enum BusinessType {
  HOTEL
  RESTAURANT
  RETAIL
  HYBRID
}

/// Rol de usuario
enum UserRole {
  OWNER
  ADMIN
  MANAGER
  SUPERVISOR
  OPERATOR
  AUDITOR
  VIEWER
}

/// Unidad de medida base
enum BaseUnit {
  UNIT
  GRAM
  KILOGRAM
  LITER
  MILLILITER
  METER
  CENTIMETER
}
